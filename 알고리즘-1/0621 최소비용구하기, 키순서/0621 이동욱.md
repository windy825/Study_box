## 0621

<br>

<br>

#### 최소 비용 구하기

```python
#시간초과
from sys import stdin
from collections import deque

def bfs():
    Q = deque()
    Q.append(s)
    while Q:
        now = Q.popleft()
        for go, cost in lst[now]:
            if cost_lst[go] > cost_lst[now] + cost and cost_lst[e] > cost_lst[now] + cost:
                cost_lst[go] = cost_lst[now] + cost
                Q.append(go)


N = int(stdin.readline())
M = int(stdin.readline())
lst = [[] for _ in range(N+1)]
cost_lst = [100000 * N] * M
for i in range(M):
    S, E, C = list(map(int, stdin.readline().split()))
    lst[S].append([E, C])

s, e = map(int, stdin.readline().split())
cost_lst[s] = 0
bfs()
print(cost_lst[e])

#통과
from sys import stdin
import heapq

N = int(stdin.readline())
M = int(stdin.readline())
lst = [[] for _ in range(N+1)]
inf = int(1e9)
cost_lst = [inf] * (N+1)
for i in range(M):
    S, E, C = list(map(int, stdin.readline().split()))
    lst[S].append([E, C])

s, e = map(int, stdin.readline().split())
cost_lst[s] = 0
Q = [(0, s)]
while Q:
    c, n = heapq.heappop(Q)
    if cost_lst[n] == c:
        for go, cost in lst[n]:
            now_cost = cost_lst[n] + cost
            if cost_lst[go] > now_cost:
                cost_lst[go] = now_cost
                heapq.heappush(Q, (now_cost, go))
print(cost_lst[e])

```

<br>

<br>

#### 키순서

```python
# 플로이드 와샬
from sys import stdin

N, M = map(int, stdin.readline().split())
visited = [[0] * (N+1) for _ in range(N+1)]

for _ in range(M):
    s, t = map(int, stdin.readline().split())
    visited[s][t] = 1

for k in range(1, N+1):
    for i in range(1, N+1):
        if k == i:
            continue
        for j in range(1, N+1):
            if i == j:
                continue
            if visited[i][k] and visited[k][j]:
                visited[i][j] = 1
answer = 0

for i in range(1, N+1):
    num = 0
    for j in range(1, N+1):
        num += visited[i][j] + visited[j][i]
    if num == N-1:
        answer += 1
print(answer)

```

<br>

---

*end*