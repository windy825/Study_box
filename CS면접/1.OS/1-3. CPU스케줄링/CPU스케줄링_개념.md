# CPU 스케줄링

<br>

### 0. 요약

![제목 없음](https://user-images.githubusercontent.com/89068148/166134120-ebef128d-7092-4051-bba8-708b110d4b2f.png)

<br>

|   구분   |                          선점 방식                           |                         비선점 방식                          |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| **개념** |                 실행중인 프로세스 중단 가능                  |                 실행중인 프로세스 중단 불가                  |
| **특징** | 하드웨어(Timer) 필요<br>공유데이터에 대한 프로세스 동기화 필요 |  특수 하드웨어(Timer) 없음<br />종료 시 까지 계속 CPU 점유   |
| **장점** |      비교적 빠른 응답<br />대화식 시분할 시스템에 적합       | 응답시간 예상 용이<br />모든 프로세스에 대한 요구를 공정하게 처리 |
| **단점** | 높은 우선순위 프로세스들이 들어오는 경우<br />오버헤드 초래  | 짧은 작업을 수행하는 프로세스가<br />긴 작업이 종료될때 까지 대기 |
| **방식** |        Round Robin, SRT, 다단계 큐, 다단계 피드백 큐         |      우선순위 스케줄링, 기한부 스케줄링, FCFS, SJF, HRN      |
| **활용** |             실시간 응답 환경, Deadline 응답 환경             |           처리시간 편차가 적은 특정 프로세스 환경            |

<br>

|                 **알고리즘**                  | **처리방식**                                                 |
| :-------------------------------------------: | :----------------------------------------------------------- |
|               RR (Round Robin)                | ![img](http://blog.skby.net/blog/wp-content/uploads/2019/02/2-31-300x107.png) <br />– 대화식 사용자 위한 시분할 시스템 – 준비 큐(FCFS)에 의해 보내진 각 프로세스는 같은 크기의 CPU 시간을 할당 받음 * First Come First Speed <br />– 프로세스가 할당된 시간 내에 처리 완료 못하면 준비 큐(FCFS) 리스트의 가장 뒤로 보내지고 CPU는 대기중인 다음 프로세스로 넘어감 <br />– 일반적 시간 할당량 100 밀리 초에서 1, 2초 사이 <br />– 할당 시간 크면 FCFS, 작으면 문맥 교환 발생   <br />– 프로세스: 컴퓨터 내에서 실행중인 프로그램의 인스턴스 |
|          SRT (Short Remaining Time)           | ![img](http://blog.skby.net/blog/wp-content/uploads/2019/02/3-18-300x71.png)<br />– 가장 짧은 시간 소요 판단되는 프로세스 수행 <br />– 남은 처리 시간이 짧은 프로세스가 준비 큐에 생기면 언제라도 프로세스 선점 <br />– 긴 작업은 SJF 보다 대기 시간이 길다 |
|         다단계 큐 (Multi-level Queue)         | ![img](http://blog.skby.net/blog/wp-content/uploads/2019/02/4-11-300x130.png)<br />– 작업들을 여러 종류의 그룹의 분할 <br />– 여러 개의 큐를 이용 상위 단계 작업에 의해 하위 단계 작업이 선점 당함 <br />– 준비 상태 큐를 여러 종류로 분할(작업 분류 별 묶음) 하지만 다른 큐로 작업 이동 불가 <br />– 각 큐는 자신만의 독자적인 스케줄링을 가짐 |
| 다단계 피드백 큐 (Multi-Level Feedback Queue) | ![img](http://blog.skby.net/blog/wp-content/uploads/2019/02/5-7-300x114.png)<br />– 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU Time Slice 부여 <br />– 새로운 프로세스는 높은 우선순위, 실행 시간이 길어질수록 점점 낮은 우선순위 큐로 이동 (맨 마지막 단계에서는 Round Robin 처리) <br />– 하위단계일수록 할당 시간 증가(공평성 부여) |

<br>

---

[시분할시스템](https://ko.wikipedia.org/wiki/%EC%8B%9C%EB%B6%84%ED%95%A0_%EC%8B%9C%EC%8A%A4%ED%85%9C)

**문맥 교환** : CPU를 다른 프로세스로 교환하기 위하여 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 적재하는 작업 

<br>

**MLQ vs MLFQ**

가장 큰 차이점은 MLQ 스케줄링의 경우 큐와 큐 사이에 프로세스들이 이동을 할 수 없는 반면, MFQ 스케줄링의 경우 큐 사이에 프로세스들이 이동을 할 수 있습니다. 따라서 MFQ 스케줄링에 비해 MLQ 스케줄링은 스케줄링 부담이 적지만 유연성은 떨어집니다. 또한 MLQ 스케줄링의 경우 하위 단계의 큐에 있을수록 CPU 할당을 받지 못하여 기아 현상이 발생할 수도 있지만 MFQ 스케줄링의 경우는 에이징 기법을 통해 기아 현상을 예방할 수 있습니다.

[참고한 블로그](https://jhnyang.tistory.com/156)