# 면접 연습하기 

<br>

#### **0. Process Scheduling?**

여러 프로세스가 있고, 이 프로세스들이 자원(CPU 등)을 동시에 요구하는데 자원이 제한되어 있다. 그러면 제한된 자원들을 어떻게(순서를 할당하는 등) 나눠줄 것인지에 대한 정책을 말한다. 

 <br>

#### **1. CPU Scheduling?**

CPU 하나는 동시에 여러개의 프로세스를 처리할 수 없기 때문에, 한 순간에 어떤 프로세스가 CPU를 사용할 수 있게 하는지 결정하는 정책이다. 

 <br>

#### 2. **CPU** **스케줄링은 언제 발생하는가?**

- 실행상태에서 대기상태로 전환될 때 (예, 입출력 요청) - Non preemptive(비선점)
- 실행상태에서 준비상태로 전환될 때 (예, 인터럽트 발생) - preemptive(선점)
- 대기상태에서 준비상태로 전환될 때(예, 입출력이 종료될 때)
- 종료될 때(Terminated)

 <br>

<br>

### 3. **CPU** **스케줄링의 종류?**

#### 비선점(Non-preemptive) 스케줄링

\- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법이다.

\- 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다. 

\- 일괄 처리 방식의 스케줄링(공정하지만 긴급 응답을 요하는 작업에 좋지 않다.)

 <br>

- **FCFS**(FIFO) : 준비상태 큐에 도착한 순서에 따라 CPU를 할당하는 기법. 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 됨.
  - 장점 : 평균 응답시간이 길다. (대화식 시스템에 부적합)
  - 단점 : 도착 순서에 따라 공평하다.
- **SJF**(Shortest Job First) : 실행시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 기법. 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
  - 장점 : 평균 응답 시간을 최소화 할 수 있다.
  - 단점 : 실행시간이 긴 프로세스는 CPU를 할당받지 못하고 무한히 대기하는 현상 발생(starvation) 
- **HRN**(Highest Response ratio) : 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로 우선순위 계산 결과 값이 높은 것부터 우선순위가 부여된다. 대기 시간이 길수록 계산 결과가 높다. 우선순위 = (대기시간 + 서비스시간 / 서비스시간) 큰 프로세스일수록 우선순위가 낮으므로 평균 응답시간도 단축
- **기한부**(DeadLine) : 프로세스에게 일정한 시간을 주어 그 시간 안에 프로세스를 완료하도록 하는 기법
- **우선순위**(Priority) : 준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법. 정적, 동적 우선순위 방법 존재

 <br>

#### 선점(Preemptive) 스케줄링

\- 하나의 프로세스가 CPU를 할당받아 실행 하고 있을 때 우선순위가 높은 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법

\- 선점으로 인한 많은 오버헤드가 발생한다.

\- 시분할 시스템에 사용하는 스케줄링이다. (긴급을 요하는 우선순위를 갖는 시분할 처리, 실시간 처리에 유용)

\- 선점을 위해 시간 배당을 위한 인터럽트용 타이머 클럭(Clock)이 필요한다.

 <br>

- **SRT**(Shortest Remaining Time) : 

  현재 실행 중인 프로세스의 남은 시간과 대기 큐에 프로세스의 실행시간이 가장 짧은 프로세스에게 CPU를 할당하는 기법 (비선점 기법인 SJF 알고리즘의 선점 형태로 변경한 기법)

  - 단점 : 잦은 선점으로 인한 문맥교환의 부담, starvation 의 위험

- **선점 우선순위** : 준비상태 큐의 프로세스들 중에서 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법

- **RR**(Round Robin) : 시분할 시스템을 위해 고안된 방법으로, FCFS 알고리즘을 선점 형태로 변형한 기법. 대기 큐를 사용하여 먼저 대기한 작업이 먼저 CPU를 사용한다.

  - 단점 : CPU를 사용할 수 있는 시간(Quantum)동안 CPU를 사용한 후에 다시 대기 큐의 가장 뒤로 배치된다. 할당되는 시간이 클 경우 FCFS 기법과 같아지고, 시간이 작을 경우 문맥교환 및 오버헤드가 자주 발생됨

- **MLQ(다단계 큐)** : 프로세스를 특정 그룹으로 분류할 수 있는 경우 그룹에 따라 각기 다른 준비상태 큐를 사용한다. 작업들을 여러 종류의 그룹으로 분할. 큐들간에 프로세스 이동이 불가능하다. 각 큐는 자신만의 독자적인 스케줄링을 가진다. 상위 우선 순위의 큐가 Empty 이면 하위 우선순위의 큐의 프로세스가 수행된다.

- **MLFQ(다단계 피드백 큐)** : 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계 큐 기법을 준비상태 큐 사이를 이동할 수 있도록 개선한 기법. 새로운 프로세스는 높은 우선순위, 프로세스의 실행이 길어질 수록 점점 낮은 우선순위 큐로 이동. 제일 마지막 단계에서는 RR/FCFS 처리. 우선순위가 높은 단계의 큐일수록 시간 할당량을 작게 설정한다. 기아 상태를 예방하는 Aging 방법. 현대 OS에서 RR방식과 함께 가장 많이 사용되는 스케줄링 기법.

- **RM**(Rate Monotonic, 주기단조) 알고리즘 : 수행 주기가 가장 짧은 프로세스에 가장 높은 우선순위를 부여하는 실시간 스케줄링 알고리즘. 정적 스케줄링방식. 마감 시간과 주기가 일치.

  - 장점 : 간단, 사용률이 0.69이하일때 항상 스케줄링 가능
  - 단점 : 주기가 긴 태스크들의 우선순위가 낮아서 장시간 대기

- **EDF**(Earliest Deadline First, 최단 마감시간 우선)알고리즘 : 프로세스의 마감시한이 가까울수록 우선순위를 높게 부여하는 선점방식의 동적 스케줄링

  - 장점 : 이론적으로 총 이용률이 1이하면 스케줄링 가능
  - 단점 : 태스크들의 수행 시간, 마감시간, 주기 등을 정확히 예측하는 것이 현실적으로 어려움.

<br>

### [정리]

비선점형 : FCFS, 비선점형 SJF 

선점형 : RR, MLQ, MLFQ, 선점형 SJF(SRF), RM(Rate Monotonic), EDF

 <br>

#### 4. **선점 스케줄링과 비선점 스케줄링의 차이점?**

선점(사용중인 cpu ) : Ex) RR, SRT, MLQ, MFQ

비선점 :  Ex) FCFS, SJR, HRN

 <br>

---

 <br>

**오버헤드**

```
프로그램의 실행흐름에서 나타나는 현상중 하나로, 
프로그램의 실행흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때 , 
추가적으로 시간,메모리,자원이 사용되는 현상.

즉, 오버 헤드는 특정 기능을 수행하는데 드는 간접적인 시간, 메모리 등 자원을 말한다. 
예를들어, 10초 걸리는 기능이 간접적인 원인으로 20초걸린다면 오버헤드는 10초가 되는것이다. 
```



 

